Ziel
Baue ein Projektmanagementsystem mit integrierter Zeiterfassung, inklusive Projekt-/Aufgabenverwaltung, Berichten und Export. Das System läuft komplett in Docker (dev & prod). Backend: Python (FastAPI bevorzugt), Frontend: React (Vite), DB: PostgreSQL, Auth: Keycloak (OIDC, dockerisiert).
Muss-Funktionen
Auth & Rollen (über Keycloak)
OIDC Authorization Code Flow mit PKCE.
Rollen: admin, project_manager, member.
Realms/Clients:
Realm: pm-realm
Client (Frontend, public): pm-frontend mit gültigen Redirect-URIs.
Client (Backend, confidential): pm-backend (Client Secret) für Token-Introspection optional; präferiert JWT-Verifikation ohne Introspection.
Scopes/Claims:
Standard OIDC + benutzerdefiniert roles (realm roles) im Access Token.
Mappers: realm roles → realm_access.roles.
Session Mgmt: Access + Refresh Tokens. Logout triggert Keycloak Endsession Endpoint.
User-Self-Service: Passwort-Reset, E-Mail-Verifikation (Keycloak SMTP konfigurierbar).
Projekte & Aufgaben
Projekt CRUD: name, client, budget_hours, billable_rate, status (planned/active/on_hold/closed), start_date, end_date, tags.
Aufgaben pro Projekt: title, description, status (todo/in_progress/done), priority, estimate_hours, assignees[], labels[].
Kanban + Listenansicht, Suche/Filter, Massenaktionen (Status ändern, Zuweisung).
Zeiterfassung
Manuelle Buchung: date, start_time, end_time oder duration_min, project_id, task_id (optional), billable (bool), hourly_rate (fallback: projektweit), note.
Live-Timer (Start/Stop) pro Aufgabe, verhindert parallele Timer.
Validierungen: keine Überlappungen pro Nutzer, duration > 0, Projekt/Task muss existieren, optional Tagesmax (konfigurierbar).
Kalender-/Wochenansicht, Summen pro Tag/Projekt.
Berichte & Export
Filter: Zeitraum, Projekt(e), Person(en), billable/non-billable.
KPIs: Ist-Stunden vs. Budget, abrechenbare Summe, Auslastung (%).
Exporte: CSV/Excel; einfache PDF-Rechnungsvorlage (Kunde, Positionen, Logo).
Administration
Nur admin: Systemsettings (Zeitzone, Standard-Stundensatz, Firmeninfos), Audit-Log (Logins, CRUD auf Projekte/Tasks/TimeEntries), einfache Mandantenfähigkeit via org_id (optional).
Nicht-funktionale Anforderungen
Docker-first mit docker-compose (siehe unten).
Testing: ≥70 % Coverage (Backend: pytest; Frontend: Vitest/RTL).
Security: TLS-Terminationsoption (Traefik/Nginx), Helmet-Äquivalent im Frontend, CORS minimal.
Observability: strukturierte Logs (JSON), Prometheus-/OpenTelemetry-Hooks im Backend.
Migrations: Alembic.
Timezone: serverseitig UTC, clientseitig lokale TZ mit korrekter Konvertierung.
Architektur & Services (docker-compose Skeleton)
version: "3.9" services:keycloak:image: quay.io/keycloak/keycloak:25.0command: start --optimizedenvironment:KC_DB: postgresKC_DB_URL: jdbc:postgresql://keycloak-db:5432/keycloakKC_DB_USERNAME: keycloakKC_DB_PASSWORD: keycloakKEYCLOAK_ADMIN: adminKEYCLOAK_ADMIN_PASSWORD: adminKC_HTTP_RELATIVE_PATH: /authports: ["8080:8080"]
    depends_on: [keycloak-db]
  keycloak-db:image: postgres:16environment:POSTGRES_DB: keycloakPOSTGRES_USER: keycloakPOSTGRES_PASSWORD: keycloakvolumes: ["keycloak_data:/var/lib/postgresql/data"]
  backend:build: ./backendenvironment:DATABASE_URL: postgresql+psycopg://app:app@db:5432/pmOIDC_ISSUER: http://keycloak:8080/auth/realms/pm-realmOIDC_AUDIENCE: pm-backendOIDC_JWKS_URL: http://keycloak:8080/auth/realms/pm-realm/protocol/openid-connect/certsTZ: UTCdepends_on: [db, keycloak]
    ports: ["8000:8000"]
  frontend:build: ./frontendenvironment:VITE_OIDC_AUTH_URL: http://localhost:8080/auth/realms/pm-realm/protocol/openid-connect/authVITE_OIDC_TOKEN_URL: http://localhost:8080/auth/realms/pm-realm/protocol/openid-connect/tokenVITE_OIDC_CLIENT_ID: pm-frontendVITE_API_BASE: http://localhost:8000depends_on: [backend]
    ports: ["5173:5173"]
  db:image: postgres:16environment:POSTGRES_DB: pmPOSTGRES_USER: appPOSTGRES_PASSWORD: appvolumes: ["app_data:/var/lib/postgresql/data"]
  proxy:image: nginx:alpinevolumes:- ./ops/nginx.conf:/etc/nginx/nginx.conf:roports: ["80:80"]
    depends_on: [frontend, backend]
volumes: { keycloak_data: {}, app_data: {} }
Backend (Python/FastAPI – Anforderungen)
Stack: FastAPI, SQLAlchemy 2.0, Alembic, Pydantic, httpx, python-jose oder authlib für JWT-Verifikation, uvicorn.
OIDC Middleware:
Hole JWKS von OIDC_JWKS_URL, cache/rotate Keys.
Verifiziere Access Token: iss, aud (pm-backend), exp, iat, nbf.
Extrahiere Rollen aus realm_access.roles.
RBAC Decorators: @requires("project_manager") etc.
Domain-Model (vereinfacht):
User(id, sub, email)
Project(id, name, client, budget_hours, billable_rate, status, start_date, end_date, tags[])
Task(id, project_id, title, description, status, priority, estimate_hours, labels[])
TimeEntry(id, user_id, project_id, task_id?, date, start_ts, end_ts, duration_min, billable, hourly_rate, note)
AuditLog(id, actor_sub, action, entity, entity_id, at)
REST API (Auszug):
/api/projects GET/POST; /api/projects/{id} GET/PATCH/DELETE
/api/projects/{id}/tasks GET/POST
/api/tasks/{id} GET/PATCH/DELETE
/api/time-entries GET/POST; /api/time-entries/{id} PATCH/DELETE
/api/reports/summary?from=&to=&user=&project=&billable=
/api/me (Echo aus Token: sub, email, roles)
Regeln Zeiterfassung:
Server berechnet duration_min aus start_ts/end_ts falls nicht gesetzt.
Kein Overlap je (user_id, date); 422 bei Konflikt.
hourly_rate default = Project.billable_rate.
Seeder & Fixtures: Admin-User/Rollen in Keycloak (per kc-admin CLI/Import JSON), Demo-Projekte/Tasks in DB.
Frontend (React/Vite – Anforderungen)
Auth: Keycloak JS Adapter oder oidc-client-ts; PKCE; Silent refresh.
App-Shell: Top-Nav (User/Logout), Sidebar (Projekte, Aufgaben, Zeiten, Berichte, Admin).
Views:
Projekte (Tabelle, Filter, CRUD-Dialoge)
Aufgaben (Kanban + Liste, Drag&Drop)
Zeiterfassung (Tages-/Wochenansicht, Timer-Widget, Schnellbuchung)
Berichte (Filter, Diagramme, Export Buttons)
Admin (nur mit Rolle admin)
State/Libs: React Query (API-Cache), React Router, Zod/React Hook Form, recharts (Charts).
i18n/UX: Deutsch/Englisch, Datum/Zeit lokal, Tastaturkürzel (Start/Stop Timer).
Keycloak Setup (automatisierbar)
Beim Start importiere eine Realm-JSON (Volumes oder Init-Script) mit:
Realm pm-realm
Clients pm-frontend (public), pm-backend (confidential)
Roles: admin, project_manager, member
Client scopes: roles Mapper → Access Token
Beispiel-Nutzer: admin@example.com (admin), pm@example.com (project_manager), user@example.com (member)
Env-Variablen im Frontend für Auth-Endpoints/Client-ID; im Backend für ISS, JWKS, AUD.
Sicherheit & Compliance
CORS: nur frontend-Origin erlauben.
CSRF: Frontend nutzt Authorization Header (Bearer); state-Parameter + PKCE.
Rate-Limiting: Basic (z. B. fastapi-limiter) für schreibende Endpunkte.
Input-Validierung: Pydantic Schemas; Sanitizing für Notizen.
Logs: Korrelation über X-Request-ID, strukturierte JSON-Logs.
Tests & CI
Backend: pytest, Testcontainers (Postgres), Faker; API-Contract-Tests (OpenAPI).
Frontend: Vitest + React Testing Library; e2e mit Playwright (Login-Flow via Keycloak Test-Realm).
CI: Lint, Tests, Build, Docker-Images, Compose-Smoke-Test.
Beispiel: Backend Token-Validation (Pseudocode)
from fastapi import FastAPI, Depends, HTTPException, Headerfrom jose import jwtimport httpx, time
JWKS_URL = os.environ["OIDC_JWKS_URL"]
ISS = os.environ["OIDC_ISSUER"]
AUD = os.environ["OIDC_AUDIENCE"]
# fetch & cache JWKS; on kid miss, refetch def verify_token(auth_header: str = Header(..., alias="Authorization")):
    scheme, _, token = auth_header.partition(" ")
    if scheme.lower() != "bearer": raise HTTPException(401)
    header = jwt.get_unverified_header(token)
    jwk = jwks_cache.get(header["kid"]) or refresh_jwks_and_get(header["kid"])
    claims = jwt.decode(token, jwk, audience=AUD, issuer=ISS, options={"verify_at_hash": False})
    if claims["exp"] < time.time(): raise HTTPException(401)
    return claims  # contains realm_access.roles 
Beispiel: Frontend OIDC Konfiguration (Kurz)
// using oidc-client-ts export const oidcConfig = {
  authority: import.meta.env.VITE_OIDC_AUTHORITY, // e.g. http://localhost:8080/auth/realms/pm-realmclient_id: import.meta.env.VITE_OIDC_CLIENT_ID, // pm-frontendredirect_uri: window.location.origin + "/callback",
  response_type: "code",
  scope: "openid profile email",
  automaticSilentRenew: true,
  loadUserInfo: true,
};
Akzeptanzkriterien (Definition of Done)
Login/Logout über Keycloak funktioniert; Rollen werden im Frontend sichtbar (z. B. Badge) und im Backend erzwungen (RBAC Tests vorhanden).
Projekte/Tasks/Zeiteinträge: vollständige CRUD-Flows, Validierungen, Kanban Drag&Drop, Timer verhindert Parallel-Sessions.
Berichte liefern korrekte Summen & Exporte (CSV/XLSX), Beispiel-PDF generierbar.
Docker Compose: docker compose up startet alle Services; Seed-Realm & DB-Migrations laufen automatisch.
OpenAPI UI unter /docs; Frontend nutzt .env korrekt; End-to-End Tests grün.